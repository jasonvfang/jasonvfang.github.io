<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Blog.Haoyi.DEV</title>
    <link>https://blog.haoyi.dev/post/</link>
    <description>Recent content in Posts on Blog.Haoyi.DEV</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sun, 05 Aug 2018 13:32:51 +0800</lastBuildDate>
    <atom:link href="https://blog.haoyi.dev/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Linux 命令行参数处理</title>
      <link>https://blog.haoyi.dev/2018/08/05/linux-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86</link>
      <pubDate>Sun, 05 Aug 2018 13:32:51 +0800</pubDate>
      
      <guid>https://blog.haoyi.dev/2018/08/05/linux-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86</guid>
      <description>

&lt;p&gt;前几天遇到对不同情况下，有个命令的处理条件需要区别的任务，看了下原始的代码，发现难以改动，太多的HARD CODE了，直接使用argv[i]的方式获取参数值显得特别
不好修改，于是想到Linux下有专门的getopt方法，好在不算改动特别大，对以前的做法作了兼容处理，好吧，这里还是对getopt作个简要的整理吧，方便日后回顾。&lt;/p&gt;

&lt;h3 id=&#34;简要说明:9284131cc5c0199dcf069c5d40516616&#34;&gt;简要说明&lt;/h3&gt;

&lt;p&gt;getopt/getopt_long都是linux平台下为应用程序提供处理命令行参数的接口，区别在于后者有参数名称长度较长的情况，一般在Linux下的命令行参数以横框“-”或者双横杠
“&amp;ndash;”进行传递，比如我们经常用到的ls -l 或者 ls &amp;ndash;help ，其中的l和help为选项。&lt;/p&gt;

&lt;h3 id=&#34;如何在程序中使用:9284131cc5c0199dcf069c5d40516616&#34;&gt;如何在程序中使用&lt;/h3&gt;

&lt;p&gt;在man手册上的定义如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;

int getopt(int argc, char * const argv[], const char *optstring);

extern char *optarg;
extern int optind, opterr, optopt;

#include &amp;lt;getopt.h&amp;gt;

int getopt_long(int argc, char * const argv[], const char *optstring,
            const struct option *longopts, int *longindex);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两个API的参数不用多说了，需要注意的是getopt/getopt_long需要循环调用处理命令行参数，也就是一般在while循环中调用。&lt;/p&gt;

&lt;p&gt;一般参数选项有需要接值的类型和不需指定参数值以及可选指定值三种情况，不同的情况有特定的写法，&lt;/p&gt;

&lt;p&gt;对于getopt来讲：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;需要指定参数值要在选项后面接一个冒号&lt;/li&gt;
&lt;li&gt;不需要指定参数值则选项后面不接任何符号&lt;/li&gt;
&lt;li&gt;可选参数值则在选项后接两个冒号&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于getopt_long来说，在option结构体中
struct option {
               const char *name;
               int         has_arg;
               int        *flag;
               int         val;
           };
的has_arg变量有三个值可以指定：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;no_argument&lt;/li&gt;
&lt;li&gt;required_argument&lt;/li&gt;
&lt;li&gt;optional_argument&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;返回值:9284131cc5c0199dcf069c5d40516616&#34;&gt;返回值&lt;/h3&gt;

&lt;p&gt;对于短的选项：
如果getopt/getopt_log在命令行参数中找到相应字符，则会返回该选项的字符，如果所有的命令参数选项都解析完成，则返回-1，
如果发现命令行参数选项中的字符不在指定的optstring中出现，则返回特殊的问号字符？。如果遇到该参数选项需要指定值而命令行中未指定时，
返回值取决于optstring中的第一个冒号字符：，如果它是冒号，则返回：，否则返回？。&lt;/p&gt;

&lt;p&gt;对于长选项：
正常情况下，如果flag为NULL，则返回option结构体中的val值，否则返回0。其他出错，未匹配以及-1的情况同短选项是一样的。&lt;/p&gt;

&lt;h3 id=&#34;两个示例:9284131cc5c0199dcf069c5d40516616&#34;&gt;两个示例&lt;/h3&gt;

&lt;p&gt;官网给出的两个示例非常实用：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;getopt&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;       #include &amp;lt;unistd.h&amp;gt;
       #include &amp;lt;stdlib.h&amp;gt;
       #include &amp;lt;stdio.h&amp;gt;

       int
       main(int argc, char *argv[])
       {
           int flags, opt;
           int nsecs, tfnd;

           nsecs = 0;
           tfnd = 0;
           flags = 0;
           while ((opt = getopt(argc, argv, &amp;quot;nt:&amp;quot;)) != -1) {
               switch (opt) {
               case &#39;n&#39;:
                   flags = 1;
                   break;
               case &#39;t&#39;:
                   nsecs = atoi(optarg);
                   tfnd = 1;
                   break;
               default: /* &#39;?&#39; */
                   fprintf(stderr, &amp;quot;Usage: %s [-t nsecs] [-n] name\n&amp;quot;,
                           argv[0]);
                   exit(EXIT_FAILURE);
               }
           }

           printf(&amp;quot;flags=%d; tfnd=%d; nsecs=%d; optind=%d\n&amp;quot;,
                   flags, tfnd, nsecs, optind);

           if (optind &amp;gt;= argc) {
               fprintf(stderr, &amp;quot;Expected argument after options\n&amp;quot;);
               exit(EXIT_FAILURE);
           }

           printf(&amp;quot;name argument = %s\n&amp;quot;, argv[optind]);

           /* Other code omitted */

           exit(EXIT_SUCCESS);
       }
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;getopt_long&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;        #include &amp;lt;stdio.h&amp;gt;     /* for printf */ 
        #include &amp;lt;stdlib.h&amp;gt;    /* for exit */ 
        #include &amp;lt;getopt.h&amp;gt;

        int main(int argc, char **argv) {
           int c;
           int digit_optind = 0;

           while (1) {
               int this_option_optind = optind ? optind : 1;
               int option_index = 0;
               static struct option long_options[] = {
                   {&amp;quot;add&amp;quot;,     required_argument, 0,  0 },
                   {&amp;quot;append&amp;quot;,  no_argument,       0,  0 },
                   {&amp;quot;delete&amp;quot;,  required_argument, 0,  0 },
                   {&amp;quot;verbose&amp;quot;, no_argument,       0,  0 },
                   {&amp;quot;create&amp;quot;,  required_argument, 0, &#39;c&#39;},
                   {&amp;quot;file&amp;quot;,    required_argument, 0,  0 },
                   {0,         0,                 0,  0 }
               };

               c = getopt_long(argc, argv, &amp;quot;abc:d:012&amp;quot;,
                        long_options, &amp;amp;option_index);
               if (c == -1)
                   break;

               switch (c) {
               case 0:
                   printf(&amp;quot;option %s&amp;quot;, long_options[option_index].name);
                   if (optarg)
                       printf(&amp;quot; with arg %s&amp;quot;, optarg);
                   printf(&amp;quot;\n&amp;quot;);
                   break;

               case &#39;0&#39;:
               case &#39;1&#39;:
               case &#39;2&#39;:
                   if (digit_optind != 0 &amp;amp;&amp;amp; digit_optind != this_option_optind)
                   printf(&amp;quot;digits occur in two different argv elements.\n&amp;quot;);
                   digit_optind = this_option_optind;
                   printf(&amp;quot;option %c\n&amp;quot;, c);
                   break;

               case &#39;a&#39;:
                   printf(&amp;quot;option a\n&amp;quot;);
                   break;

               case &#39;b&#39;:
                   printf(&amp;quot;option b\n&amp;quot;);
                   break;

               case &#39;c&#39;:
                   printf(&amp;quot;option c with value &#39;%s&#39;\n&amp;quot;, optarg);
                   break;

               case &#39;d&#39;:
                   printf(&amp;quot;option d with value &#39;%s&#39;\n&amp;quot;, optarg);
                   break;

               case &#39;?&#39;:
                   break;

               default:
                   printf(&amp;quot;?? getopt returned character code 0%o ??\n&amp;quot;, c);
               }
           }

           if (optind &amp;lt; argc) {
               printf(&amp;quot;non-option ARGV-elements: &amp;quot;);
               while (optind &amp;lt; argc)
                   printf(&amp;quot;%s &amp;quot;, argv[optind++]);
               printf(&amp;quot;\n&amp;quot;);
           }

           exit(EXIT_SUCCESS); }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;超详细参考资料在&lt;a href=&#34;http://man7.org/linux/man-pages/man3/getopt.3.html&#34;&gt;这里&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linux FD操作问题</title>
      <link>https://blog.haoyi.dev/2018/07/18/linux-fd%E6%93%8D%E4%BD%9C%E9%97%AE%E9%A2%98</link>
      <pubDate>Wed, 18 Jul 2018 00:10:51 +0800</pubDate>
      
      <guid>https://blog.haoyi.dev/2018/07/18/linux-fd%E6%93%8D%E4%BD%9C%E9%97%AE%E9%A2%98</guid>
      <description>

&lt;p&gt;主要总结一之前工作中遇到的问题，在对一个fifo进行操作的时候出现无法open的情况，但是fifo文件是一直存在的，百思不得解，
后面还是同事的提醒，才想起看到man手册中的说明，先上代码吧，自己写的一个小程序测试：
&lt;img src=&#34;https://blog.haoyi.dev/images/open_demo_codes.png&#34; alt=&#34;Demo 代码&#34; /&gt;&lt;/p&gt;

&lt;p&gt;注意这里的模式是只写模式加非阻塞模式,运行结果是：
&lt;img src=&#34;https://blog.haoyi.dev/images/open_error.png&#34; alt=&#34;运行结果&#34; /&gt;&lt;/p&gt;

&lt;p&gt;MAN手册上的说明：
&lt;img src=&#34;https://blog.haoyi.dev/images/man_open_flag.png&#34; alt=&#34;MAN解释&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;总结:a351240390739a29de3a0ddadb1844ae&#34;&gt;总结：&lt;/h2&gt;

&lt;p&gt;使用O_RDONLY或O_WRONLY设置打开FIFO时:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果设置了O_NONBLOCK，则open()用于读取时只会立即返回。如果当前没有任何进程打开文件进行读取，则以只写的方式写FD时会返回一个错误。&lt;/li&gt;
&lt;li&gt;如果O_NONBLOCK没有指定，那么只读的open()将阻塞调用线程，直到线程打开文件进行写入。以只写方式open()调用将会阻塞调用线程，直到线程打开文件进行读取。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此本例中的解决办法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1.可以设置open的方式为block方式&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;2. 在write之前，其他进程一直在读fd&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>cmake学习简要总结</title>
      <link>https://blog.haoyi.dev/2018/07/15/cmake%E5%AD%A6%E4%B9%A0%E7%AE%80%E8%A6%81%E6%80%BB%E7%BB%93</link>
      <pubDate>Sun, 15 Jul 2018 23:10:51 +0800</pubDate>
      
      <guid>https://blog.haoyi.dev/2018/07/15/cmake%E5%AD%A6%E4%B9%A0%E7%AE%80%E8%A6%81%E6%80%BB%E7%BB%93</guid>
      <description>

&lt;p&gt;今天有时间去研究一下cmake的使用，之前一直是想看一下的，只是时间没排出来，今天总算排上了，收获也挺多，感觉
这样的编译工具确实比我们自己写Makefile管理起来要好的多，这也就是为什么在开源社区会有这么多的开源软件的编译都采用的cmake吧。&lt;/p&gt;

&lt;p&gt;不废话了，今天按照官方文档把整个例子跑了一遍，基本上知道如何使用了。&lt;/p&gt;

&lt;h4 id=&#34;大致总结一下吧:578a5a155bc08a6ef951443a54099335&#34;&gt;大致总结一下吧：&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;cmake根据CMakeLists.txt文件自动生成Makefile
也就是cmake是可配置的，其次它有一个方便的GUI工具实现配置，这个我暂时没有研究到。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;cmake可指定宏编译选项、子目录、install、目标&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;常用的也应该就这些，理解这些大致修改足够了：&lt;/p&gt;

&lt;p&gt;宏：option()
子目录：
头文件子目录：include_directories  编译子目录：add_subdirectory&lt;/p&gt;

&lt;p&gt;install: install()可指定FILES或者TARGETS&lt;/p&gt;

&lt;p&gt;add_executable():指定生成的target及需要的src文件&lt;/p&gt;

&lt;p&gt;target_link_libraries：指定链接的lib&lt;/p&gt;

&lt;p&gt;这里是官方文档中的一个例子，写的很清楚了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cmake_minimum_required (VERSION 2.6)
project (Tutorial)
# The version number.
set (Tutorial_VERSION_MAJOR 1)
set (Tutorial_VERSION_MINOR 0)

 # should we use our own math functions?
option (USE_MYMATH 
        &amp;quot;Use tutorial provided math implementation&amp;quot; ON) 
        
# configure a header file to pass some of the CMake settings
# to the source code
configure_file (
  &amp;quot;${PROJECT_SOURCE_DIR}/TutorialConfig.h.in&amp;quot;
  &amp;quot;${PROJECT_BINARY_DIR}/TutorialConfig.h&amp;quot;
  )
 
# add the binary tree to the search path for include files
# so that we will find TutorialConfig.h
include_directories(&amp;quot;${PROJECT_BINARY_DIR}&amp;quot;)
 
# add the MathFunctions library?
#
if (USE_MYMATH)
  include_directories (&amp;quot;${PROJECT_SOURCE_DIR}/MathFunctions&amp;quot;)
  add_subdirectory (MathFunctions)
  set (EXTRA_LIBS ${EXTRA_LIBS} MathFunctions)
endif (USE_MYMATH)

     
# add the executable
add_executable (Tutorial tutorial.cxx)
target_link_libraries (Tutorial  ${EXTRA_LIBS})

# add the install targets
install (TARGETS Tutorial DESTINATION ~/bin)
install (FILES &amp;quot;${PROJECT_BINARY_DIR}/TutorialConfig.h&amp;quot;        
         DESTINATION ~/include)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在github中已经把这些步骤的尝试都上传了，可见&lt;a href=&#34;https://github.com/jasonvfang/cmake-examples&#34;&gt;这里&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;参考详细教程：&lt;a href=&#34;https://cmake.org/cmake-tutorial/&#34;&gt;https://cmake.org/cmake-tutorial/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hugo summary length 限制</title>
      <link>https://blog.haoyi.dev/2018/06/24/hugo-summary-length-%E9%99%90%E5%88%B6</link>
      <pubDate>Sun, 24 Jun 2018 16:10:51 +0800</pubDate>
      
      <guid>https://blog.haoyi.dev/2018/06/24/hugo-summary-length-%E9%99%90%E5%88%B6</guid>
      <description>&lt;p&gt;本文将说明如何在HUGO中对摘要进行长度限制。&lt;/p&gt;

&lt;p&gt;体验了一下HUGO静态网站生成，的确很amazing！&lt;/p&gt;

&lt;p&gt;初次写文章时发现首页上的摘要有点显示过长了，GOOGLE了很久，有说配置summary length的属性，试过不行，
其实在官方DOC中已经写明了，请参考&lt;a href=&#34;https://gohugo.io/variables/page/&#34;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;只需要在需要进行分隔的地方添加一个``````标签即可，这样标签后面的内容则需要点Read more才可完全显示。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Libcurl中的HTTP重定向问题</title>
      <link>https://blog.haoyi.dev/2018/06/23/libcurl%E4%B8%AD%E7%9A%84http%E9%87%8D%E5%AE%9A%E5%90%91%E9%97%AE%E9%A2%98</link>
      <pubDate>Sat, 23 Jun 2018 12:10:51 +0800</pubDate>
      
      <guid>https://blog.haoyi.dev/2018/06/23/libcurl%E4%B8%AD%E7%9A%84http%E9%87%8D%E5%AE%9A%E5%90%91%E9%97%AE%E9%A2%98</guid>
      <description>

&lt;p&gt;最近一调试AMAZON的Prime Music音源接口，主要是HTTP POST/GET这种方法获取的JSON结果进行解析，工作内容相对比较简单，但是需要注意的地方比较多：&lt;/p&gt;

&lt;h4 id=&#34;几个注意点:14060e7e7718326a13d6ba00d594b5b1&#34;&gt;几个注意点&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;JSON的内存释放&lt;/li&gt;
&lt;li&gt;HTTP请求RESP是否有重定向问题
在处理这个HTTP返回时就有遇到过重定向的坑，导致浪费太多的时间&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;curl的http选项:14060e7e7718326a13d6ba00d594b5b1&#34;&gt;CURL的HTTP选项&lt;/h5&gt;

&lt;p&gt;基本参考CURL的SAMPLE CODE就可以完成：
先上大致的code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        curl_easy_setopt(g_curl_handle, CURLOPT_SSL_VERIFYPEER, 1L);
        curl_easy_setopt(g_curl_handle, CURLOPT_SSL_VERIFYHOST, 2L);
        curl_easy_setopt(g_curl_handle, CURLOPT_MAXCONNECTS, 10);
        curl_easy_setopt(g_curl_handle, CURLOPT_TIMEOUT, 15);
        curl_easy_setopt(g_curl_handle, CURLOPT_SERVER_RESPONSE_TIMEOUT, 15);
        curl_easy_setopt(g_curl_handle, CURLOPT_DEBUGFUNCTION, my_trace);
        curl_easy_setopt(g_curl_handle, CURLOPT_DEBUGDATA, &amp;amp;config);
        curl_easy_setopt(g_curl_handle, CURLOPT_WRITEFUNCTION, write_data);
        curl_easy_setopt(g_curl_handle, CURLOPT_WRITEDATA, result_buffer);
        curl_easy_setopt(g_curl_handle, CURLOPT_HEADERFUNCTION, header_callback);
        curl_easy_setopt(g_curl_handle, CURLOPT_WRITEHEADER, header_buffer);
        curl_easy_setopt(g_curl_handle, CURLOPT_USERAGENT, &amp;quot;libcurl-agent/1.0&amp;quot;);
        curl_easy_setopt(g_curl_handle, CURLOPT_NOSIGNAL, 1L); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在执行http request的时候一直得到的空数据，利用POSTMAN进行模拟都能够正确返回数据，后来通过命令行CURL模拟发现HTTP STATUS返回的是3XX，于是才恍然大悟，需要设置CURL的重定向跟踪功能：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//follow redirect url
curl_easy_setopt(g_curl_handle, CURLOPT_FOLLOWLOCATION, 1L);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;加上这个设置后完美解决，建议后面实现HTTP请求的所有功能都应该加上这个设置，避免得到空数据。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>如何判断单链表有环</title>
      <link>https://blog.haoyi.dev/2016/11/21/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%8D%95%E9%93%BE%E8%A1%A8%E6%9C%89%E7%8E%AF</link>
      <pubDate>Mon, 21 Nov 2016 17:22:51 +0800</pubDate>
      
      <guid>https://blog.haoyi.dev/2016/11/21/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%8D%95%E9%93%BE%E8%A1%A8%E6%9C%89%E7%8E%AF</guid>
      <description>

&lt;p&gt;从自己的CSDN BLOG移过来的文章，作个BACKUP:&lt;/p&gt;

&lt;h4 id=&#34;1-对于单链表而言-只有通过从头到尾的遍历方式-如果发现尾指针指向头指针则说明有环:f72815461b815b1a8f39d32ad1ee5cce&#34;&gt;1、对于单链表而言，只有通过从头到尾的遍历方式，如果发现尾指针指向头指针则说明有环：&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;bool hasCycle(struct ListNode *head)
{
    if(head == NULL || head-&amp;gt;next == NULL){
        return false;
    }
    
    struct ListNode *ptr = head-&amp;gt;next;
    
    while(ptr)
    {
        if (ptr-&amp;gt;next == head){
            return true;
        }   
        
        if (ptr-&amp;gt;next == NULL)
            break;
            
        ptr = ptr-&amp;gt;next;    
    }
    
    return false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-使用双指针-一个遍历的速度快-一个较慢-如果快的指针追上了慢的那个说明有环:f72815461b815b1a8f39d32ad1ee5cce&#34;&gt;2、使用双指针，一个遍历的速度快，一个较慢，如果快的指针追上了慢的那个说明有环：&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
bool hasCycle(struct ListNode *head) 
{
    struct ListNode *faster = NULL;
    struct ListNode *slower = NULL;
    
    if(head == NULL || head-&amp;gt;next == NULL){
        return false;
    }
    
    slower = head;
    faster = head-&amp;gt;next;
    while(faster != slower){
        if(faster == NULL || faster-&amp;gt;next == NULL)
        {
            return false;
        }
        
        faster = faster-&amp;gt;next-&amp;gt;next;
        slower = slower-&amp;gt;next;
    }
    
    return true;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>我居然看了《冠军》-2012-06</title>
      <link>https://blog.haoyi.dev/2012/06/23/%E6%88%91%E5%B1%85%E7%84%B6%E7%9C%8B%E4%BA%86%E5%86%A0%E5%86%9B-2012-06</link>
      <pubDate>Sat, 23 Jun 2012 23:20:51 +0800</pubDate>
      
      <guid>https://blog.haoyi.dev/2012/06/23/%E6%88%91%E5%B1%85%E7%84%B6%E7%9C%8B%E4%BA%86%E5%86%A0%E5%86%9B-2012-06</guid>
      <description>&lt;p&gt;一篇2012年的日记，想不到我也有这样的一面，觉得以前的自己比现在好，不知道为啥会这样想，也许现在在社会上混的比较久了的原因吧，BACKUP回来，回到2012的端午：&lt;/p&gt;

&lt;p&gt;因为端午节的原因，同学都回家了，我家隔得比较远，所以没回，这两天也没什么事就开始在风行上搜索电影来看，以打发时间，实际上平时也没太多心思去看电影，这样的话正好可以在这样的时候安静的享受下，搜寻了半天最终还是选择看车太贤主演的《冠军》，网上评论说有点像以前的《奔腾年代》，看完后也许有两分相似吧，不过更加的感人。&lt;/p&gt;

&lt;p&gt;《冠军》中，车太贤饰演是一个怀有梦想的骑手李承浩，因为一次交通意外而失去自己的妻子，留下一个小女儿，而在那次交通事故中同样的也一匹马（冰雹）失去了自己的孩子，不幸地瘸了一条腿，李承浩也因为这次事故自己的视力变得很差，也许正是这起事外改变了这匹不一般的马吧，这匹马就是走不出丧子的悲痛，任凭任何人去尝试着去驯服它，始终不起作用，碰巧被李承浩碰见了，马和狗一样，都是非常有灵性的动物，经历一翻曲折的过程，终于被李承浩驯服，就是因为有一段相似的悲痛或许才让冰雹得以释放自己压抑的情怀，两者走在了一起，人与马“容“为一体，就像那位很有经验的骑手说的那样&amp;ndash;”只有人和马达到很高的默契、容为一体才能称得上骑手，才能赢得比赛！“，不负众望，冰雹和李承浩连续赢下了三场比赛，最后晋及决赛，开心胜利的背后总会存在着一些不好的一面，李承浩的视力越来越差，当骑手是一个冒死的选择，但是他坚持了，那匹特殊的马，为什么称为特殊？就像那位兽医说的那样&amp;ndash;”我不知道为什么，这匹马是那种宁可跑死在终点也不会退出比赛的马！“，除了李承浩没有别人能够驾驭住它~！影片中李承浩因为视力问题而不能继续当骑手的这一段情节过程中，出现了很多感人的朋友、亲情的感人画面，在决赛冲刺的那一刻，李承浩眼睛什么都看不见，受伤坚持的冰雹像失去知觉一样的奔跑着，李承浩从马上摔飞的一幕，冰雹没有继续狂奔而是回头跑到李承浩跟前将其”拉”起，两“人”一起走完了最后三十米的跑程，全场观众也感动的直喊“加油！”，当然影片中也不仅仅全是一些感人的画面，定位为喜剧片当然里面也包含着一大堆的搞笑画面，有喜有悲、给人的心灵感觉上尝到不同的转换效果，这的确说明了我也被感动了！人生是不放弃，坚持到底！这是影片的主题，这匹马和李承浩体现了，表现了，很精彩！&lt;/p&gt;

&lt;p&gt;以前也看过车太贤的电影，诸如《笨蛋》、还有几个名字想不起来了，实力派的演员，很喜欢看他的作品，我也不知道为什么看韩国人的电影，虽然爱情肥皂剧的居多（我很少看这种），但是在情感描绘方面确实是很能感动观众（也许我是一个很容易触动的观众吧），希望以后能多看看这种电影，当自己一个人郁闷的时候，事业爱情或者其他什么情况中遇到不顺的时候，这都是一个很好的安抚剂，缓过去。看来抽时间看一下电影也是个不错的选择，至少能让你的脑海里不再只是学习或者工作~~《冠军》，值得一看~一部电影就像是一部小说，我把它归类到读书笔记中&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>