[{"categories":["programming"],"contents":"默认hugo启用server时会绑定在localhost(127.0.0.1)上，在外网上无法通过IP访问，只能通过本机输入localhost访问， 那么如何启用Server可用于IP访问：\n hugo server -b http://10.240.218.181 --bind=\u0026quot;0.0.0.0\u0026quot; -D ","date":"Aug 12","permalink":"https://blog.haoyi.dev/post/start_server_with_ip/","tags":["hugo"],"title":"Hugo启用自定义IP绑定"},{"categories":null,"contents":"","date":"Nov 26","permalink":"https://blog.haoyi.dev/articles/","tags":null,"title":"Articles"},{"categories":["programming"],"contents":"前几天遇到对不同情况下，有个命令的处理条件需要区别的任务，看了下原始的代码，发现难以改动，太多的HARD CODE了，直接使用argv[i]的方式获取参数值显得特别 不好修改，于是想到Linux下有专门的getopt方法，好在不算改动特别大，对以前的做法作了兼容处理，好吧，这里还是对getopt作个简要的整理吧，方便日后回顾。\n   简要说明  getopt/getopt_long都是linux平台下为应用程序提供处理命令行参数的接口，区别在于后者有参数名称长度较长的情况，一般在Linux下的命令行参数以横框“-”或者双横杠 “\u0026ndash;”进行传递，比如我们经常用到的ls -l 或者 ls \u0026ndash;help ，其中的l和help为选项。\n   如何在程序中使用  在man手册上的定义如下：\n#include \u0026lt;unistd.h\u0026gt;\rint getopt(int argc, char * const argv[], const char *optstring);\rextern char *optarg;\rextern int optind, opterr, optopt;\r#include \u0026lt;getopt.h\u0026gt;\rint getopt_long(int argc, char * const argv[], const char *optstring,\rconst struct option *longopts, int *longindex);\r这两个API的参数不用多说了，需要注意的是getopt/getopt_long需要循环调用处理命令行参数，也就是一般在while循环中调用。\n一般参数选项有需要接值的类型和不需指定参数值以及可选指定值三种情况，不同的情况有特定的写法，\n对于getopt来讲：\n 需要指定参数值要在选项后面接一个冒号 不需要指定参数值则选项后面不接任何符号 可选参数值则在选项后接两个冒号  对于getopt_long来说，在option结构体中 struct option { const char *name; int has_arg; int *flag; int val; }; 的has_arg变量有三个值可以指定：\n no_argument required_argument optional_argument     返回值  对于短的选项： 如果getopt/getopt_log在命令行参数中找到相应字符，则会返回该选项的字符，如果所有的命令参数选项都解析完成，则返回-1， 如果发现命令行参数选项中的字符不在指定的optstring中出现，则返回特殊的问号字符？。如果遇到该参数选项需要指定值而命令行中未指定时， 返回值取决于optstring中的第一个冒号字符：，如果它是冒号，则返回：，否则返回？。\n对于长选项： 正常情况下，如果flag为NULL，则返回option结构体中的val值，否则返回0。其他出错，未匹配以及-1的情况同短选项是一样的。\n   两个示例  官网给出的两个示例非常实用：\n getopt   #include \u0026lt;unistd.h\u0026gt;\r#include \u0026lt;stdlib.h\u0026gt;\r#include \u0026lt;stdio.h\u0026gt;\rint\rmain(int argc, char *argv[])\r{\rint flags, opt;\rint nsecs, tfnd;\rnsecs = 0;\rtfnd = 0;\rflags = 0;\rwhile ((opt = getopt(argc, argv, \u0026quot;nt:\u0026quot;)) != -1) {\rswitch (opt) {\rcase 'n':\rflags = 1;\rbreak;\rcase 't':\rnsecs = atoi(optarg);\rtfnd = 1;\rbreak;\rdefault: /* '?' */\rfprintf(stderr, \u0026quot;Usage: %s [-t nsecs] [-n] name\\n\u0026quot;,\rargv[0]);\rexit(EXIT_FAILURE);\r}\r}\rprintf(\u0026quot;flags=%d; tfnd=%d; nsecs=%d; optind=%d\\n\u0026quot;,\rflags, tfnd, nsecs, optind);\rif (optind \u0026gt;= argc) {\rfprintf(stderr, \u0026quot;Expected argument after options\\n\u0026quot;);\rexit(EXIT_FAILURE);\r}\rprintf(\u0026quot;name argument = %s\\n\u0026quot;, argv[optind]);\r/* Other code omitted */\rexit(EXIT_SUCCESS);\r}\rgetopt_long  \t#include \u0026lt;stdio.h\u0026gt; /* for printf */ #include \u0026lt;stdlib.h\u0026gt; /* for exit */ #include \u0026lt;getopt.h\u0026gt;\rint main(int argc, char **argv) {\rint c;\rint digit_optind = 0;\rwhile (1) {\rint this_option_optind = optind ? optind : 1;\rint option_index = 0;\rstatic struct option long_options[] = {\r{\u0026quot;add\u0026quot;, required_argument, 0, 0 },\r{\u0026quot;append\u0026quot;, no_argument, 0, 0 },\r{\u0026quot;delete\u0026quot;, required_argument, 0, 0 },\r{\u0026quot;verbose\u0026quot;, no_argument, 0, 0 },\r{\u0026quot;create\u0026quot;, required_argument, 0, 'c'},\r{\u0026quot;file\u0026quot;, required_argument, 0, 0 },\r{0, 0, 0, 0 }\r};\rc = getopt_long(argc, argv, \u0026quot;abc:d:012\u0026quot;,\rlong_options, \u0026amp;option_index);\rif (c == -1)\rbreak;\rswitch (c) {\rcase 0:\rprintf(\u0026quot;option %s\u0026quot;, long_options[option_index].name);\rif (optarg)\rprintf(\u0026quot; with arg %s\u0026quot;, optarg);\rprintf(\u0026quot;\\n\u0026quot;);\rbreak;\rcase '0':\rcase '1':\rcase '2':\rif (digit_optind != 0 \u0026amp;\u0026amp; digit_optind != this_option_optind)\rprintf(\u0026quot;digits occur in two different argv elements.\\n\u0026quot;);\rdigit_optind = this_option_optind;\rprintf(\u0026quot;option %c\\n\u0026quot;, c);\rbreak;\rcase 'a':\rprintf(\u0026quot;option a\\n\u0026quot;);\rbreak;\rcase 'b':\rprintf(\u0026quot;option b\\n\u0026quot;);\rbreak;\rcase 'c':\rprintf(\u0026quot;option c with value '%s'\\n\u0026quot;, optarg);\rbreak;\rcase 'd':\rprintf(\u0026quot;option d with value '%s'\\n\u0026quot;, optarg);\rbreak;\rcase '?':\rbreak;\rdefault:\rprintf(\u0026quot;?? getopt returned character code 0%o ??\\n\u0026quot;, c);\r}\r}\rif (optind \u0026lt; argc) {\rprintf(\u0026quot;non-option ARGV-elements: \u0026quot;);\rwhile (optind \u0026lt; argc)\rprintf(\u0026quot;%s \u0026quot;, argv[optind++]);\rprintf(\u0026quot;\\n\u0026quot;);\r}\rexit(EXIT_SUCCESS); }\r超详细参考资料在这里.\n","date":"Aug 05","permalink":"https://blog.haoyi.dev/post/getopt_usage/","tags":["linux-c"],"title":"Linux 命令行参数处理"},{"categories":["Programming"],"contents":"主要总结一之前工作中遇到的问题，在对一个fifo进行操作的时候出现无法open的情况，但是fifo文件是一直存在的，百思不得解， 后面还是同事的提醒，才想起看到man手册中的说明，先上代码吧，自己写的一个小程序测试： 注意这里的模式是只写模式加非阻塞模式,运行结果是： MAN手册上的说明：    总结：  使用O_RDONLY或O_WRONLY设置打开FIFO时:\n 如果设置了O_NONBLOCK，则open()用于读取时只会立即返回。如果当前没有任何进程打开文件进行读取，则以只写的方式写FD时会返回一个错误。 如果O_NONBLOCK没有指定，那么只读的open()将阻塞调用线程，直到线程打开文件进行写入。以只写方式open()调用将会阻塞调用线程，直到线程打开文件进行读取。  因此本例中的解决办法：\n 1.可以设置open的方式为block方式  在write之前，其他进程一直在读fd    ","date":"Jul 18","permalink":"https://blog.haoyi.dev/post/open_fd_question/","tags":["linux c"],"title":"Linux FD操作问题"},{"categories":["cmake"],"contents":"今天有时间去研究一下cmake的使用，之前一直是想看一下的，只是时间没排出来，今天总算排上了，收获也挺多，感觉 这样的编译工具确实比我们自己写Makefile管理起来要好的多，这也就是为什么在开源社区会有这么多的开源软件的编译都采用的cmake吧。\n不废话了，今天按照官方文档把整个例子跑了一遍，基本上知道如何使用了。\n   大致总结一下吧：    cmake根据CMakeLists.txt文件自动生成Makefile 也就是cmake是可配置的，其次它有一个方便的GUI工具实现配置，这个我暂时没有研究到。\n  cmake可指定宏编译选项、子目录、install、目标\n  常用的也应该就这些，理解这些大致修改足够了：\n宏：option() 子目录： 头文件子目录：include_directories 编译子目录：add_subdirectory\ninstall: install()可指定FILES或者TARGETS\nadd_executable():指定生成的target及需要的src文件\ntarget_link_libraries：指定链接的lib\n这里是官方文档中的一个例子，写的很清楚了：\ncmake_minimum_required (VERSION 2.6)\rproject (Tutorial)\r# The version number.\rset (Tutorial_VERSION_MAJOR 1)\rset (Tutorial_VERSION_MINOR 0)\r# should we use our own math functions?\roption (USE_MYMATH \u0026quot;Use tutorial provided math implementation\u0026quot; ON) # configure a header file to pass some of the CMake settings\r# to the source code\rconfigure_file (\r\u0026quot;${PROJECT_SOURCE_DIR}/TutorialConfig.h.in\u0026quot;\r\u0026quot;${PROJECT_BINARY_DIR}/TutorialConfig.h\u0026quot;\r)\r# add the binary tree to the search path for include files\r# so that we will find TutorialConfig.h\rinclude_directories(\u0026quot;${PROJECT_BINARY_DIR}\u0026quot;)\r# add the MathFunctions library?\r#\rif (USE_MYMATH)\rinclude_directories (\u0026quot;${PROJECT_SOURCE_DIR}/MathFunctions\u0026quot;)\radd_subdirectory (MathFunctions)\rset (EXTRA_LIBS ${EXTRA_LIBS} MathFunctions)\rendif (USE_MYMATH)\r# add the executable\radd_executable (Tutorial tutorial.cxx)\rtarget_link_libraries (Tutorial ${EXTRA_LIBS})\r# add the install targets\rinstall (TARGETS Tutorial DESTINATION ~/bin)\rinstall (FILES \u0026quot;${PROJECT_BINARY_DIR}/TutorialConfig.h\u0026quot; DESTINATION ~/include)\r在github中已经把这些步骤的尝试都上传了，可见这里.\n参考详细教程：https://cmake.org/cmake-tutorial/\n","date":"Jul 15","permalink":"https://blog.haoyi.dev/post/cmake_summary/","tags":["cmake"],"title":"cmake学习简要总结"},{"categories":["Hugo"],"contents":"本文将说明如何在HUGO中对摘要进行长度限制。\n体验了一下HUGO静态网站生成，的确很amazing！\n初次写文章时发现首页上的摘要有点显示过长了，GOOGLE了很久，有说配置summary length的属性，试过不行， 其实在官方DOC中已经写明了，请参考这里。\n只需要在需要进行分隔的地方添加一个\u0026lt;!--more--\u0026gt;标签即可，这样标签后面的内容则需要点Read more才可完全显示。\n","date":"Jun 24","permalink":"https://blog.haoyi.dev/post/hugo_summary_len/","tags":["hugo"],"title":"Hugo summary length 限制"},{"categories":["Programming"],"contents":"最近一调试AMAZON的Prime Music音源接口，主要是HTTP POST/GET这种方法获取的JSON结果进行解析，工作内容相对比较简单，但是需要注意的地方比较多：\n   几个注意点   JSON的内存释放 HTTP请求RESP是否有重定向问题 在处理这个HTTP返回时就有遇到过重定向的坑，导致浪费太多的时间     CURL的HTTP选项  基本参考CURL的SAMPLE CODE就可以完成： 先上大致的code:\n curl_easy_setopt(g_curl_handle, CURLOPT_SSL_VERIFYPEER, 1L); curl_easy_setopt(g_curl_handle, CURLOPT_SSL_VERIFYHOST, 2L); curl_easy_setopt(g_curl_handle, CURLOPT_MAXCONNECTS, 10); curl_easy_setopt(g_curl_handle, CURLOPT_TIMEOUT, 15); curl_easy_setopt(g_curl_handle, CURLOPT_SERVER_RESPONSE_TIMEOUT, 15); curl_easy_setopt(g_curl_handle, CURLOPT_DEBUGFUNCTION, my_trace); curl_easy_setopt(g_curl_handle, CURLOPT_DEBUGDATA, \u0026amp;config); curl_easy_setopt(g_curl_handle, CURLOPT_WRITEFUNCTION, write_data); curl_easy_setopt(g_curl_handle, CURLOPT_WRITEDATA, result_buffer); curl_easy_setopt(g_curl_handle, CURLOPT_HEADERFUNCTION, header_callback); curl_easy_setopt(g_curl_handle, CURLOPT_WRITEHEADER, header_buffer); curl_easy_setopt(g_curl_handle, CURLOPT_USERAGENT, \u0026quot;libcurl-agent/1.0\u0026quot;); curl_easy_setopt(g_curl_handle, CURLOPT_NOSIGNAL, 1L); 在执行http request的时候一直得到的空数据，利用POSTMAN进行模拟都能够正确返回数据，后来通过命令行CURL模拟发现HTTP STATUS返回的是3XX，于是才恍然大悟，需要设置CURL的重定向跟踪功能：\n//follow redirect url curl_easy_setopt(g_curl_handle, CURLOPT_FOLLOWLOCATION, 1L); 加上这个设置后完美解决，建议后面实现HTTP请求的所有功能都应该加上这个设置，避免得到空数据。\n","date":"Jun 23","permalink":"https://blog.haoyi.dev/post/libcurl_redirect_sum/","tags":["libcurl"],"title":"Libcurl中的HTTP重定向问题"},{"categories":null,"contents":"Jobs: Senior Software Engineer\nMainly concentrate on Linux/Embed and IOT. But also great passion on researching other skills(Server end developing \u0026amp; Web etc).\nFull stack developing.\nLanguages: C/C++ mainly, go/python/web etc. Love opensource and github.\nLocation: ShangHai,China\nContact: jasonvfang@gmail.com\n","date":"May 19","permalink":"https://blog.haoyi.dev/about/","tags":null,"title":"About"},{"categories":["Programming"],"contents":"从自己的CSDN BLOG移过来的文章，作个BACKUP:\n   1、对于单链表而言，只有通过从头到尾的遍历方式，如果发现尾指针指向头指针则说明有环：  bool hasCycle(struct ListNode *head)\r{\rif(head == NULL || head-\u0026gt;next == NULL){\rreturn false;\r}\rstruct ListNode *ptr = head-\u0026gt;next;\rwhile(ptr)\r{\rif (ptr-\u0026gt;next == head){\rreturn true;\r}\tif (ptr-\u0026gt;next == NULL)\rbreak;\rptr = ptr-\u0026gt;next;\t}\rreturn false;\r}\r   2、使用双指针，一个遍历的速度快，一个较慢，如果快的指针追上了慢的那个说明有环：  /**\r* Definition for singly-linked list.\r* struct ListNode {\r* int val;\r* struct ListNode *next;\r* };\r*/\rbool hasCycle(struct ListNode *head) {\rstruct ListNode *faster = NULL;\rstruct ListNode *slower = NULL;\rif(head == NULL || head-\u0026gt;next == NULL){\rreturn false;\r}\rslower = head;\rfaster = head-\u0026gt;next;\rwhile(faster != slower){\rif(faster == NULL || faster-\u0026gt;next == NULL)\r{\rreturn false;\r}\rfaster = faster-\u0026gt;next-\u0026gt;next;\rslower = slower-\u0026gt;next;\r}\rreturn true;\r}\r","date":"Nov 21","permalink":"https://blog.haoyi.dev/post/howto_judge_linklist_cycle/","tags":["algorithm"],"title":"如何判断单链表有环"}]